#!/usr/bin/env python3
# Output formatter for MemSift results

import os
import time
import dicttoxml
from tabulate import tabulate

class OutputFormatter:
    """Formats and exports results from memory scanning"""
    
    def __init__(self, options, misc):
        """Initialize with options and misc utilities"""
        self.options = options
        self.misc = misc
    
    def format_results(self, results):
        """Format results based on the specified output format"""
        if self.options.output_format == "xml":
            return self._format_xml(results)
        elif self.options.output_format == "html":
            return self._format_html(results)
        else:  # Default to plain text
            return self._format_plain(results)
    
    def _format_plain(self, results):
        """Format results as plain text"""
        if not results:
            return "No results found."
        
        lines = ["Pattern\tMatch\tProcess"]
        lines.append("-" * 80)
        
        for result in results:
            pattern = result['pattern']
            match = result['match']
            proc_info = result['process_info']
            lines.append(f"{pattern}\t{match}\t{proc_info}")
        
        return "\n".join(lines)
    
    def _format_xml(self, results):
        """Format results as XML"""
        if not results:
            return "<results></results>"
        
        # Convert to XML using dicttoxml
        xml = dicttoxml.dicttoxml(results, custom_root='results', attr_type=False)
        return xml.decode('utf-8')
    
    def _format_html(self, results):
        """Format results as HTML with styled table"""
        if not results:
            return self._html_wrapper("<p>No results found.</p>")
        
        # Prepare data for tabulate
        table_data = []
        for result in results:
            table_data.append([
                result['pattern'],
                result['match'],
                result['process_info']
            ])
        
        # Generate HTML table
        table_html = tabulate(
            table_data,
            headers=["Pattern", "Match", "Process"],
            tablefmt="html"
        )
        
        # Add CSS styling
        return self._html_wrapper(table_html)
    
    def _html_wrapper(self, content):
        """Wrap content in HTML with styling"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>MemSift Results - {timestamp}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f8f8f8;
            color: #333;
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }}
        .info {{
            background-color: #d5e9f6;
            border-left: 5px solid #3498db;
            padding: 10px;
            margin: 15px 0;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
        }}
        th {{
            background-color: #2c3e50;
            color: white;
            padding: 12px;
            text-align: left;
        }}
        td {{
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }}
        tr:nth-child(even) {{
            background-color: #f2f2f2;
        }}
        tr:hover {{
            background-color: #e3e3e3;
        }}
        .footer {{
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
            color: #7f8c8d;
        }}
    </style>
</head>
<body>
    <h1>MemSift Memory Analysis Results</h1>
    <div class="info">
        <p><strong>Scan Time:</strong> {timestamp}</p>
    </div>
    {content}
    <div class="footer">
        <p>Generated by MemSift - Memory Extraction and Analysis Tool</p>
    </div>
</body>
</html>"""
        return html
    
    def write_to_file(self, results):
        """Write formatted results to the specified output file"""
        if not self.options.output_file:
            return
        
        try:
            formatted_results = self.format_results(results)
            
            # Create directory if it doesn't exist
            output_dir = os.path.dirname(self.options.output_file)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            with open(self.options.output_file, 'w') as f:
                f.write(formatted_results)
                
            self.misc.print_success(f"Results written to {self.options.output_file}")
        except Exception as e:
            self.misc.print_error(f"Error writing results to file: {str(e)}")
    
    def print_results(self, results):
        """Print results to standard output"""
        if not results:
            self.misc.print_info("No results found.")
            return
        
        # For plain text output, print to console
        if self.options.output_format == "plain":
            self.misc.print_info(f"Found {len(results)} matches:")
            
            table_data = []
            for result in results:
                table_data.append([
                    result['pattern'],
                    result['match'],
                    result['process_info']
                ])
            
            print(tabulate(
                table_data,
                headers=["Pattern", "Match", "Process"],
                tablefmt="simple"
            ))
        else:
            # For other formats, just inform that results are being written to file
            self.misc.print_info(f"Results are being formatted as {self.options.output_format.upper()}")
            if self.options.output_file:
                self.misc.print_info(f"Check {self.options.output_file} for formatted output")
            else:
                # If no output file specified but format is not plain, print formatted output
                print(self.format_results(results))
